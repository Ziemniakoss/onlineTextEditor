/// Editor server and messages generated by server(like connected itp)
use actix::prelude::*;
use rand::{self, rngs::ThreadRng, Rng};
use std::collections::{HashMap};
use crate::editor_session;
use crate::editor_session::{FileCreationRequest, EditorSession, FileDeletionRequest};
use crate::models::{User, Project, ProjectFile};
use log::{info, error, warn};
use serde::Serialize;
use crate::repositories::users::get_user;
use crate::services::projects_files::{IProjectsFilesService, CreationError, ServiceCreationError, DeletionError};


#[derive(Message)]
#[rtype(result = "()")]
pub struct Message(pub String);

#[derive(Message)]
#[rtype(usize)]
pub struct Connect {
	pub addr: Recipient<Message>,
	pub project_id: i32,
}


#[derive(Message)]
#[rtype(result = "()")]
pub struct Disconnect {
	pub id: i32,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct ClientMessage {
	/// Id of the client session
	pub id: i32,
	/// Peer message
	pub msg: String,
	pub project_id: i32,
}


#[derive(Message)]
#[rtype(result = "()")]
pub struct ErrorMessage {
	pub msg: String
}

struct SessionData {
	pub id: i32,
	pub user: User,
	pub project_id: i32,
	pub recipient: Addr<EditorSession>,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct EditorServer {
	sessions_2: HashMap<i32, SessionData>,
	rng: ThreadRng,
}

#[derive(Message)]
#[rtype(result = "()")]
#[derive(Clone)]
pub struct FileCreated {
	pub id: i32,
	pub name: String,
}

#[derive(Message)]
#[rtype(result = "()")]
#[derive(Clone)]
pub struct FileDeleted {
	pub id: i32
}

#[derive(Serialize)]
#[derive(Message)]
#[rtype(result = "()")]
pub struct ProjectInfoDto {
	pub project: Project,
	pub files: Vec<ProjectFile>,
	pub sessions: Vec<SessionDataDto>,
}

#[derive(Serialize)]
pub struct SessionDataDto {
	id: i32,
	name: String,
}

impl Default for EditorServer {
	fn default() -> EditorServer {
		println!("Creat");
		EditorServer {
			sessions_2: HashMap::new(),
			rng: rand::thread_rng(),
		}
	}
}

impl EditorServer {
	fn send_message(&self, project_id: i32, message: &str) {
		println!("Sending message to all editin: {}", project_id);
		let _ = self.sessions_2.values().into_iter()
			.filter(|session_data| session_data.project_id == project_id)
			.for_each(|session| {
				let _ = session.recipient.do_send(Message(message.to_owned()));
			});
	}

	/// Tries to send ProjectInfoDto to actor. If actor does not have access to project or this project
	/// does not exist. It will send error message to actor and return false
	///
	/// # Returns
	///  - false if this actor does not have access to this project or project does not exists.
	/// - true otherwise
	///
	fn send_project_info(&self, addr: &Addr<EditorSession>, session_data: &SessionData) -> bool {
		let projects_service = crate::services::projects::new(session_data.user.clone());
		let project;
		match projects_service.get(session_data.project_id) {
			Ok(p) => project = p,
			Err(_) => {
				error!("Error while trying to get project for ProjectInfoDto: Project does not exists or user have no access");
				self.send_error(addr, "You don't have access to this project or this project does not exist".to_owned());
				return false;
			}
		}
		let projects_files_service;
		match crate::services::projects_files::new(session_data.user.id, project.id.unwrap()) {
			Ok(service) => projects_files_service = service,
			Err(_) => return false//already handled
		}
		let files = projects_files_service.get_all();
		let mut sessions: Vec<SessionDataDto> = self.sessions_2.iter()
			.map(|full_session_data| {
				return SessionDataDto { id: full_session_data.0.to_owned(), name: full_session_data.1.user.name.clone() };
			}).collect();
		sessions.push(SessionDataDto {
			id: session_data.id,
			name: session_data.user.name.clone(),
		});
		addr.do_send(ProjectInfoDto {
			project,
			files,
			sessions,
		});
		return true;
	}

	/// Sends error message to given actor
	///
	fn send_error(&self, addr: &Addr<EditorSession>, msg: String) {
		addr.do_send(ErrorMessage { msg });
	}
}

impl Actor for EditorServer {
	type Context = Context<Self>;
}

impl Handler<editor_session::FileDeletionRequest> for EditorServer {
	type Result = ();

	fn handle(&mut self, msg: FileDeletionRequest, ctx: &mut Context<Self>) -> Self::Result {
		let session_data = self.sessions_2.get(&msg.session_id).unwrap();
		let project_files_service;
		match crate::services::projects_files::new(session_data.user.id, session_data.project_id) {
			Ok(service) => project_files_service = service,
			Err(_) => {
				self.send_error(&session_data.recipient, "Project does not exist or you don't have access to it".to_owned());
				return;
			}
		}
		let file;
		match project_files_service.get(msg.file_id) {
			Some(f) => {
				file = f;
			}
			None => {
				warn!("Session {}(user {}) editing project {} tried to delete non existing file {}", session_data.id, session_data.user.id, session_data.project_id, msg.file_id);
				self.send_error(&session_data.recipient, "File does not exist".to_owned());
				return;
			}
		}
		match project_files_service.delete(file) {
			Ok(_) => {
				info!("Session {}(user{}) deleted file {} from project {}", session_data.id, session_data.user.id, msg.file_id, session_data.project_id);
				self.sessions_2.values().into_iter()
					.filter(|session| { session.project_id == session_data.project_id })
					.for_each(|session_data| {
						session_data.recipient.do_send(FileDeleted{
							id: msg.file_id
						});
					});
			}
			Err(_) => {
				error!("Unknown error occured while deleting file");
				self.send_error(&session_data.recipient, "Unknown error occured while deleting file".to_owned());
			}
		}
	}
}

/// Register new session and assign unique id to this session
impl Handler<editor_session::Connect> for EditorServer {
	type Result = i32;

	fn handle(&mut self, msg: editor_session::Connect, _: &mut Context<Self>) -> Self::Result {
		let id = self.rng.gen::<i32>();
		self.send_message(msg.project_id, &format!("1{} {}", id, msg.user.name));

		let session_data = SessionData {
			id,
			user: msg.user.clone(),
			project_id: msg.project_id,
			recipient: msg.addr.clone(),
		};
		if self.send_project_info(&msg.addr, &session_data) {
			self.sessions_2.insert(id, session_data);
			println!("New session with id {}, current sessions {}", id, self.sessions_2.len());
		} else {}
		id
	}
}

impl Handler<editor_session::Disconnect> for EditorServer {
	type Result = ();

	fn handle(&mut self, msg: editor_session::Disconnect, _: &mut Context<Self>) {
		info!("Session {} ended", msg.session_id);
		let project_id;
		match self.sessions_2.remove(&msg.session_id) {
			Some(session) => project_id = session.project_id,
			_ => return
		}
		self.send_message(project_id, &format!("2{}", msg.session_id));
	}
}

impl Handler<editor_session::FileCreationRequest> for EditorServer {
	type Result = ();

	fn handle(&mut self, msg: FileCreationRequest, ctx: &mut Context<Self>) -> Self::Result {
		let session_data = self.sessions_2.get(&msg.session_id).expect("Non existing session id");
		let projects_files_service;
		match crate::services::projects_files::new(session_data.user.id, session_data.project_id) {
			Ok(service) => projects_files_service = service,
			Err(_) => {
				self.send_error(&session_data.recipient, "You don't have access to this project".to_owned());
				return;
			}
		}
		let new_file = ProjectFile {
			id: None,
			name: msg.filename,
			project_id: session_data.project_id,
		};
		let created_file;
		match projects_files_service.create(new_file) {
			Ok(file) => {
				created_file = file;
				info!("Created new file in project {} with name {} and id {}", created_file.project_id, created_file.name, created_file.id.unwrap());
			}
			Err(err) => {
				match err {
					CreationError::IllegalName => {
						self.send_error(&session_data.recipient, "Illegal new file name".to_owned());
					}
					CreationError::DuplicateNames => {
						self.send_error(&session_data.recipient, "File with that name already exists".to_owned())
					}
				}
				return;
			}
		}
		let message = FileCreated {
			id: created_file.id.expect("That would mean that file was not created"),
			name: created_file.name,
		};

		self.sessions_2.values().into_iter()
			.filter(|s| { return s.project_id == session_data.project_id; })
			.for_each(|session| {
				session.recipient.do_send(message.clone())
			});
	}
}

impl Handler<ClientMessage> for EditorServer {
	type Result = ();

	fn handle(&mut self, msg: ClientMessage, _: &mut Context<Self>) {
		self.send_message(msg.project_id, msg.msg.as_str());
	}
}

