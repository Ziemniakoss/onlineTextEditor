/// Editor server and messages generated by server(like connected itp)
use actix::prelude::*;
use rand::{self, rngs::ThreadRng, Rng};
use std::collections::{HashMap};
use crate::editor_session;
use crate::editor_session::{FileCreationRequest};
use crate::models::User;
use log::{info};

#[derive(Message)]
#[rtype(result = "()")]
pub struct Message(pub String);

#[derive(Message)]
#[rtype(usize)]
pub struct Connect {
	pub addr: Recipient<Message>,
	pub project_id: i32,
}


#[derive(Message)]
#[rtype(result = "()")]
pub struct Disconnect {
	pub id: usize,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct ClientMessage {
	/// Id of the client session
	pub id: usize,
	/// Peer message
	pub msg: String,
	pub project_id: i32,
}

/// Join room, if room does not exists create new one.
#[derive(Message)]
#[rtype(result = "()")]
pub struct Join {
	pub id: usize,
	pub project_id: i32,
}

struct SessionData {
	pub user: User,
	pub project_id: i32,
	pub recipient: Recipient<Message>,
}

pub struct EditorServer {
	sessions_2: HashMap<usize, SessionData>,
	rng: ThreadRng,
}

impl Default for EditorServer {
	fn default() -> EditorServer {
		println!("Creat");
		EditorServer {
			sessions_2: HashMap::new(),
			rng: rand::thread_rng(),
		}
	}
}

impl EditorServer {
	fn send_message(&self, project_id: i32, message: &str) {
		println!("Sending message to all editin: {}", project_id);
		let _ = self.sessions_2.values().into_iter()
			.filter(|session_data| session_data.project_id == project_id)
			.for_each(|session| {
				let _ = session.recipient.do_send(Message(message.to_owned()));
			});
	}
}

impl Actor for EditorServer {
	type Context = Context<Self>;
}

/// Register new session and assign unique id to this session
impl Handler<editor_session::Connect> for EditorServer {
	type Result = usize;

	fn handle(&mut self, msg: editor_session::Connect, _: &mut Context<Self>) -> Self::Result {
		let id = self.rng.gen::<usize>();
		self.sessions_2.insert(id, SessionData {
			user: msg.user.clone(),
			project_id: msg.project_id,
			recipient: msg.addr.recipient(),
		});
		self.send_message(msg.project_id, &format!("1{} {}", id, msg.user.name));
		println!("New session with id {}, current sessions {}", id, self.sessions_2.len());
		id
	}
}

/// Handler for Disconnect message.
impl Handler<editor_session::Disconnect> for EditorServer {
	type Result = ();

	fn handle(&mut self, msg: editor_session::Disconnect, _: &mut Context<Self>) {
		info!("Session {} ended", msg.session_id);
		let project_id;
		match self.sessions_2.remove(&msg.session_id) {
			Some(session) => project_id = session.project_id,
			_ => return
		}
		self.send_message(project_id, &format!("2{}", msg.session_id));
	}
}

impl Handler<editor_session::FileCreationRequest> for EditorServer {
	type Result = ();

	fn handle(&mut self, msg: FileCreationRequest, ctx: &mut Context<Self>) -> Self::Result {}
}

impl Handler<ClientMessage> for EditorServer {
	type Result = ();

	fn handle(&mut self, msg: ClientMessage, _: &mut Context<Self>) {
		self.send_message(msg.project_id, msg.msg.as_str());
	}
}

